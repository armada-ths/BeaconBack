{
  "name": "tcomb-validation",
  "version": "0.1.0",
  "description": "General purpose validation library for JavaScript",
  "main": "index.js",
  "scripts": {
    "test": "mocha",
    "build-playground": "watchify -v -t reactify playground/playground.jsx -o playground/playground.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/gcanti/tcomb-validation.git"
  },
  "author": {
    "name": "Giulio Canti",
    "email": "giulio.canti@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/gcanti/tcomb-validation/issues"
  },
  "homepage": "https://github.com/gcanti/tcomb-validation",
  "dependencies": {
    "tcomb": "~0.2.0"
  },
  "devDependencies": {
    "grunt": "^0.4.5",
    "grunt-cli": "^0.1.13",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-contrib-uglify": "^0.5.1",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-mocha-test": "^0.11.0",
    "istanbul": "^0.3.0",
    "jshint-stylish": "^0.4.0",
    "mocha": "^1.21.4",
    "react": "^0.11.1",
    "backbone": "^1.1.2",
    "sinon": "^1.10.3",
    "tcomb-react-bootstrap": "^0.0.4"
  },
  "tags": [
    "validation"
  ],
  "readme": "% tcomb-validation\n\n![tcomb logo](http://gcanti.github.io/resources/tcomb/logo.png)\n\nA brand new **general purpose** validation library for JavaScript\n\n# Playground\n\nTry the [playground online](https://gcanti.github.io/resources/tcomb-validation/playground/playground.html)\n\n# Overview\n\n**Features**\n\n- concise yet expressive syntax\n- validates native types, subtypes, objects, lists and tuples, enums, unions, dicts\n- validates structures with arbitrary level of nesting\n- detailed informations on failed validations\n- lightweight alternative to JSON Schema (4K gzipped bundled with [tcomb](https://github.com/gcanti/tcomb))\n- easy integration with React (`propTypes`) and Backbone (`validate` implementation)\n- output messages are fully customizable\n- reuse your domain model written with [tcomb](https://github.com/gcanti/tcomb)\n\n**Contents**\n\n- [Basic usage](#basic-usage)\n  - [Primitives](#primitives)\n  - [Subtypes](#subtypes)\n  - [Objects](#objects)\n  - [Lists and tuples](#lists-and-tuples)\n  - [Enums](#enums)\n  - [Unions](#unions)\n  - [Dicts](#dicts)\n  - [Nested structures](#nested-structures)\n- [Advanced usage and use cases](#advanced-usage-and-use-cases)\n  - [Form validation](#form-validation)\n  - [JSON schema](#json-schema)\n  - [An alternative syntax for React propTypes](#an-alternative-syntax-for-react-proptypes)\n  - [Full debugging support for React components](#full-debugging-support-for-react-components)\n  - [Backbone validation](#backbone-validation)\n  - [Full debugging support for Backbone models](#full-debugging-support-for-backbone-models)\n- [Api reference](#api-reference)\n\n# Basic usage\n\n*If you don't know how to define types with tcomb you may want to take a look at its [README](https://github.com/gcanti/tcomb/blob/master/README.md) file.*\n\nThe main function is `validate`:\n\n```js\nvalidate(value, spec) -> Result\n```\n\n- `value` the value to validate\n- `spec` a type defined with the [tcomb](https://github.com/gcanti/tcomb) library\n\nreturns a `Result` object containing the result of the validation\n\nExample\n\n```js\nvar Tcomb = require('tcomb-validation');\nvar validate = Tcomb.addons.validation.validate;\nvar Str = Tcomb.Str; // a string type\n\nvalidate(1, Str).isValid();   // => false\nvalidate('a', Str).isValid(); // => true\n```\n\nYou can inspect the result to quickly identify what's wrong:\n\n```js\nvar result = validate(1, Str);\nresult.isValid();     // => false\nresult.firstError();  // => new Error('value is `1`, should be a `Str`')\n\n// see `result.errors` to inspect all errors\n```\n\n## Primitives\n\n```js\n// null and undefined\nvalidate('a', Nil).isValid();       // => false\nvalidate(null, Nil).isValid();      // => true\nvalidate(undefined, Nil).isValid(); // => true\n\n// strings\nvalidate(1, Str).isValid();   // => false\nvalidate('a', Str).isValid(); // => true\n\n// numbers\nvalidate('a', Num).isValid(); // => false\nvalidate(1, Num).isValid();   // => true\n\n// booleans\nvalidate(1, Bool).isValid();    // => false\nvalidate(true, Bool).isValid(); // => true\n\n// optional values\nvalidate(null, maybe(Str)).isValid(); // => true\nvalidate('a', maybe(Str)).isValid();  // => true\nvalidate(1, maybe(Str)).isValid();    // => false\n\n// functions\nvalidate(1, Func).isValid();              // => false\nvalidate(function () {}, Func).isValid(); // => true\n\n// dates\nvalidate(1, Dat).isValid();           // => false\nvalidate(new Date(), Dat).isValid();  // => true\n\n// regexps\nvalidate(1, Re).isValid();    // => false\nvalidate(/^a/, Re).isValid(); // => true\n```\n\n## Subtypes\n\nYou can express more fine-grained contraints with the `subtype` syntax:\n\n```js\n// a predicate is a function with signature: (x) -> boolean\nvar predicate = function (x) { return x >= 0; };\n\n// a positive number\nvar Positive = subtype(Num, predicate);\n\nvalidate(-1, Positive).isValid(); // => false\nvalidate(1, Positive).isValid();  // => true\n```\n\n## Objects\n\n```js\n// an object with two numerical properties\nvar Point = struct({\n  x: Num, \n  y: Num\n});\n\nvalidate(null, Point).isValid();            // => false\nvalidate({x: 0}, Point).isValid();          // => false, y is missing\nvalidate({x: 0, y: 'a'}, Point).isValid();  // => false, y is not a number\nvalidate({x: 0, y: 0}, Point).isValid();    // => true\n\n```\n\n## Lists and tuples\n\n**Lists**\n\n```js\n// a list of strings\nvar Words = list(Str);\n\nvalidate(null, Words).isValid();                  // => false\nvalidate(['hello', 1], Words).isValid();          // => false, [1] is not a string\nvalidate(['hello', 'world'], Words).isValid();    // => true\n```\n\n**Tuples**\n\n```js\n// a tuple (width x height)\nvar Size = tuple([Positive, Positive]);\n\nvalidate([1], Size).isValid();      // => false, height missing\nvalidate([1, -1], Size).isValid();  // => false, bad height\nvalidate([1, 2], Size).isValid();   // => true\n```\n\n## Enums\n\n```js\nvar CssTextAlign = enums.of('left right center justify');\n\nvalidate('bottom', CssTextAlign).isValid(); // => false\nvalidate('left', CssTextAlign).isValid();   // => true\n```\n\n## Unions\n\n```js\nvar CssLineHeight = union([Num, Str]);\n\n// in order to make it work, we must implement the #dispath method\nCssLineHeight.dispatch = function (x) {\n  if (Num.is(x)) { return Num; }\n  else if (Str.is(x)) { return Str; }\n};\n\nvalidate(null, CssLineHeight).isValid();    // => false\nvalidate(1.4, CssLineHeight).isValid();     // => true\nvalidate('1.2em', CssLineHeight).isValid(); // => true\n```\n\n## Dicts\n\n```js\n// a dictionary of numbers\nvar Warranty = dict(Num);\n\nvalidate(null, Warranty).isValid();             // => false\nvalidate({US: 2, IT: 'a'}, Warranty).isValid(); // => false, ['IT'] is not a number\nvalidate({US: 2, IT: 1}, Warranty).isValid();   // => true\n```\n\n## Nested structures\n\nYou can validate structures with arbitrary level of nesting:\n\n```js\nvar Post = struct({\n  title: Str,\n  content: Str,\n  tags: Words\n});\n\nvar mypost = {\n  title: 'Awesome!',\n  content: 'You can validate structures with arbitrary level of nesting',\n  tags: ['validation', 1] // <-- ouch!\n};\n\nvalidate(mypost, Post).isValid();     // => false\nvalidate(mypost, Post).firstError();  // => new Error('tags[1] is `1`, should be a `Str`')\n```\n\n# Advanced usage and use cases\n\n## Form validation\n\nLet's design the process for a simple sign in form:\n\n```js\nvar SignInInfo = struct({\n  username: Str,\n  password: Str\n});\n\n// retrieves values from the UI\nvar formValues = {\n  username: $('#username').val().trim() || null,\n  password: $('#password').val().trim() || null\n};\n\n// if formValues = {username: null, password: 'password'}\nvar result = validate(formValues, SignInInfo);\nresult.isValid();     // => false\nresult.firstError();  // => new Error('username is `null`, should be a `Str`')\n```\n\nYou can customize the output to return your messages or simply the names of the invalid props for further processing:\n\n```js\nvar result = validate(formValues, SignInInfo, {messages: ':path'});\nresult.firstError(); // => new Error('username')\n\n// display invalid fields to the user\nresult.errors.forEach(function (err) {\n  $('#' + err.message).parent().addClass('has-error'); // Bootstrap 3\n});\n```\n\n## JSON schema\n\nIf you don't want to use a JSON Schema validator or it's not applicable, you can just use this lightweight library in a snap. This is the JSON Schema example of [http://jsonschemalint.com/](http://jsonschemalint.com/)\n\n```json\n{\n  \"type\": \"object\", \n  \"properties\": {\n    \"foo\": {\n      \"type\": \"number\"\n    }, \n    \"bar\": {\n      \"type\": \"string\", \n      \"enum\": [\n        \"a\", \n        \"b\", \n        \"c\"\n      ]\n    }\n  }\n}\n```\n\nand the equivalent `tcomb-validation` counterpart:\n\n```js\nvar Schema = struct({\n  foo: Num,\n  bar: enums.of('a b c')\n});\n```\n\nlet's validate the example JSON:\n\n```js\nvar json = {\n  \"foo\": \"this is a string, not a number\", \n  \"bar\": \"this is a string that isn't allowed\"\n};\n\nvalidate(json, Schema).isValid(); // => false\n\n// the returned errors are:\n[\n  new Error('foo is `\"this is a string, not a number\"`, should be a `Num`'),\n  new Error('bar is `\"this is a string that isn\\'t allowed\"`, should be a `enums`')\n]\n```\n\n**Note**: A feature missing in standard JSON Schema is the powerful [subtype](#subtypes) syntax.\n\n## An alternative syntax for React propTypes\n\n**UPDATE**: since the last release of this library, I wrote a separate project to maximize the control \nover React components, see [here](https://github.com/gcanti/tcomb-react).\n\nYou can also use this library as an alternative syntax for the React.js `propTypes`, taking advantage of its expressive syntax:\n\n```js\n// define the component props\nvar MyProps = struct({\n  foo: Num,\n  bar: subtype(Str, function (s) { return s.length <= 3; }, 'Bar')\n});\n\n// a simple component\nvar MyComponent = React.createClass({\n\n  propTypes: toPropTypes(MyProps), // <--- !\n\n  render: function () {\n    return (\n      <div>\n        <div>Foo is: {this.props.foo}</div>\n        <div>Bar is: {this.props.bar}</div>\n      </div>\n    );\n  }    \n});\n\n// try to use bad props\nvar props = {\n  \"foo\": \"this is a string, not a number\", \n  \"bar\": \"this is a string too long\"\n};\n\n// rendering\nReact.renderComponentToString(MyComponent(props));\n\n// prints to console:\n// => Warning: this.props.foo of value `\"this is a string, not a number\"` supplied to `undefined`, expected a `Num`\n// => Warning: Warning: this.props.bar of value `\"this is a string too long\"` supplied to `undefined`, expected a `Bar`\n```\n*You can find the `toPropTypes` function [here](https://github.com/gcanti/tcomb-react)*\n\n## Full debugging support for React components\n\n**UPDATE**: since the last release of this library, I wrote a separate project to maximize the control \nover React components, see [here](https://github.com/gcanti/tcomb-react).\n\nA complete alternative to `propTypes` is adding this simple snippet to your `render` methods to obtain a full debugging support:\n\n```js\n//\n// if bad props are passed, the debugger kicks in\n//\n// define the component props\nvar MyProps = struct({\n  foo: Num,\n  bar: subtype(Str, function (s) { return s.length <= 3; }, 'Bar'),\n  children: Any\n});\n\nvar MyComponent = React.createClass({\n  render: function () {\n    this.props = MyProps(this.props); // <--- !\n    return (\n      <div>\n        <div>Foo is: {this.props.foo}</div>\n        <div>Bar is: {this.props.bar}</div>\n      </div>\n    );\n  }    \n});\n```\n\n## Backbone validation\n\n```js\n// attributes definition\nvar Attrs = struct({\n  x: Num,\n  y: Num\n});\n\nvar options = {validate: true};\n\nvar Model = Backbone.Model.extend({\n  validate: function (attrs, options) {\n    return validate(attrs, Attrs).errors;\n  }\n});\n\n// first validation (OK)\nvar model = new Model({x: 1, y: 2}, options);\nconsole.log(model.attributes); // => { x: 1, y: 2 }\n\n// second validation (KO)\nmodel.set({x: 'a'}, options);  // bad attribute\nconsole.log(model.attributes); // => { x: 1, y: 2 } attributes are unchanged\n```\n\n## Full debugging support for Backbone models\n\nTo obtain a full debugging support simply modify the `validate` method:\n\n```js\n//\n// if bad attributes are passed, the debugger kicks in\n//\n\nvar Model = Backbone.Model.extend({\n  validate: function (attrs, options) {\n    Attrs(attrs); // <--- !\n  }\n});\n\n// bad call\nvar model = new Model({x: 1, y: 'a'}, options);\n```\n\n# Api reference\n\n## Result\n\n`Result` is a struct containing an `errors` prop which is:\n\n- a list of `Error` if validation fails \n- or `null` if succeded.\n\n```js\n// the definition of `Result`\nvar Result = struct({\n  errors: maybe(list(Err))\n});\n```\n\n### #isValid()\n\nReturns true if there are no errors.\n\n```js\nvalidate('a', Str).isValid(); // => true\n```  \n\n### #firstError()\n\nReturns the first error or `null` if validation succeded.\n\n```js\nvalidate(1, Str).firstError(); // => new Error('value is `1`, should be a `Str`')\n```  \n\n## validate(value, type, [opts]) -> Result\n\n- `value` the value to validate\n- `type` a type defined with the tcomb library\n- `opts` options hash\n\n### opts.messages\n\nCustomizes the error messages:\n\n```js\nvar Point = struct({\n  x: Num, \n  y: Num\n});\n\nvar myMessages = {\n  x: 'x should be a number',\n  y: 'y should be a number'\n};\n\nvar result = validate({x: 'a'}, Point, {messages: myMessages}); \nconsole.log(result.errors);\n\n// outputs\n[\n  new Error('x should be a number'),\n  new Error('y should be a number')\n]\n```\n\n**Placeholders**\n\nIn your custom messages, you can use the following placeholders:\n\n- `:path`: the path of the offending value\n- `:jsonpath`: the path of the offending value in [JSON Path](http://goessner.net/articles/JsonPath/) format \n- `:actual`: the actual offending value\n- `:expected`: the type of the expected value\n\n```js\nmyMessages = {\n  x: ':jsonpath = :actual instead of a :expected',\n  y: ':jsonpath = :actual instead of a :expected'\n};\n\nvar result = validate({x: 'a'}, Point, {messages: myMessages}); \nconsole.log(result.errors);\n\n// outputs\n[\n  new Error('[\"x\"] = \"a\" instead of a Num'),\n  new Error('[\"y\"] = undefined instead of a Num')\n]\n```\n\n# Tests\n\nRun `mocha` in the project root.\n\n# License (MIT)\n\nThe MIT License (MIT)\n\nCopyright (c) 2014 Giulio Canti\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "tcomb-validation@0.1.0",
  "dist": {
    "shasum": "5434301f37e78bec2709900e5fb45cce7039a11a"
  },
  "_from": "tcomb-validation@",
  "_resolved": "https://registry.npmjs.org/tcomb-validation/-/tcomb-validation-0.1.0.tgz"
}
